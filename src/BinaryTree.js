
class BinaryTree {
    constructor(x, y, backgroundColor) {
       
    }

  
    bindControls(controls) {
      
    }

    // Resets the root node to an empty node, effectively clearing all nodes
    clear() {
        
    }

    // Returns: a random number in the range [0, max) not yet in the tree
    uniqueRandom(max) {
        
    }

    // Quickly fills the tree with a certain number of nodes
    fill(count) {
        
    }

    
    addValue(value) {
        
    }


    deleteValueVisual(value){
      
    }

    searchPos(x,y){
       
    }

    // Wraps the Node class's search method directly
    search(value) {
        
    }

    setCoordinates(node) {
       
    }

    // Draws the entire visulizatino, including the background, and each node
    draw() {
     
    }

 
    updateDrawing() {
       
    }

    // Wraps the Node class's resetVisuals method, and draws the result
    resetVisuals() {
      
    }

  
    startAnimation(frame, ...args) {
       
    }

    
    continueAnimation(frame, ...args) {
        
    }

    
    stopAnimation(complete = () => {}, ...callbackArgs) {
        
    }

    addValueVisual(value, complete = () => {}, ...callbackArgs) {
        
    }

    
    addValueFrame(value, complete, ...callbackArgs) {
        
    }

   
    searchVisual(value, complete = () => {}, ...callbackArgs) {
        
    }

   
    searchFrame(value, complete, ...callbackArgs) {
        
    }

    
    fillVisual(count, complete = () => {}) {
       
    }

    fillFrame(count, filled, complete) {
       
    }

    startAnimation(frame, ...args) {
       
    }

    // Schedules the next frame of the animation
    continueAnimation(frame, ...args) {
       
    }

   
    stopAnimation(complete = () => {}, ...callbackArgs) {
        
    }

   
    addValueVisual(value, complete = () => {}, ...callbackArgs) {
        
    }

    addValueFrame(value, complete, ...callbackArgs) {
        
    }

    searchVisual(value, complete = () => {}, ...callbackArgs) {
       
    }

    searchFrame(value, complete, ...callbackArgs) {
        
    }

    
    fillVisual(count, complete = () => {}) {
        
    }

    // complete is a callback called when the animation finishes
    fillFrame(count, filled, complete) {
        
    }

}
